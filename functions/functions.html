<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>Functions</title>
  </head>
  <body>
    <h1>Functions</h1>

    <h2>Function:</h2>
    <p>Wrapping a piece of program in a value</p>

    <ul>
      <li>To structure large programs</li>
      <li>To avoid repetition</li>
      <li>To associate names with sub-programs</li>
      <li>To isolate these sub-programs from each other</li>
    </ul>

    <p>
      Function is created with an expression which starts with the keyword
      <em>function</em>
      .
    </p>

    <p>
      Functions have may a set of
      <em>parameters</em>
      , and a
      <strong>body</strong>
      -- which contains statements which are to be executed when the function is called.
    </p>

    <h2>Bindings and Scope</h2>
    <p>
      Each binding has a scope, which is the part of the program in which the
      <em>binding is visible</em>
    </p>

    <p>
      For bindings defined outside of any
      <em>function</em>
      ,
      <em>block</em>
      or a
      <em>module</em>
      , the whole program is the scope and such bindings can be referred from anywhere in the
      program. Their
      <strong>scope</strong>
      is
      <strong>global</strong>
    </p>

    <p>
      Bindings created for function parameters, or declared inside the function can be referenced
      only within function, so they are known as
      <strong>local bindings</strong>
      have local scope.
    </p>

    <p>Every time a function is called, new instances of bindings is created</p>

    <h2>let and const bindings</h2>
    <p>
      Bindings created with
      <strong>let</strong>
      and
      <strong>const</strong>
      can only be accessed within the block they are declared in.
    </p>

    <p>In Pre-2015 JavaScript, only functions created new scope with var keyword.</p>

    <h2>Lexical Scope</h2>
    <p>
      The
      <strong>set of bindings</strong>
      visible inside a block is determined by the
      <strong>place of that block</strong>
      in the program text. This approach to
      <em>binding visibility</em>
      is called
      <strong>lexical scope</strong>
      .
    </p>

    <h2>Function declaration</h2>

    <p>
      When the
      <strong>function</strong>
      keyword is used at the start of the statement, it works differently.

      <code><embed>
        
        function square(x){ 
           return x*x 
        }
</code>embed></code>
      This is a function declaration.
    </p>
    <p>
      The function definitions are happily invoked even when used on the lines above their
      declaration. Function declarations are not part of the normal top-to-bottom flow of control.
      They are conceptually moved to the top of their scope and can be used by all the code in that
      scope
    </p>


    <h2>Arrow Functions:</h2>
    <p>
        Shorter form of function expression
        <code>
            ()=>{}
        </code>
    </p>

    <p>There is no special reason to have both arrow function and function expressions in JavaScript, except for a very minor difference (to be discussed later)</p>


    <h2>Call Stack</h2>

    <p>Functions call one another</p>
    <p>When a function is called, the control is taken to the function's body being called, and when the functions returns, the control is taken back to the caller.</p>
    <p>And a mechanism is required to monitor these calls, this is where <strong>Call Stack</strong> comes in. It stores the context of caller functions and called functions, so that the control flow is managed properly.</p>

    <p>When a function is invoked, function is loaded on the top of stack, and when the function returns, the function is popped out of stack.<strong>However, this popped function helps call stack to return to the caller function.</strong></p>


    <h2>Optional Parameters:</h2>
    <p>JavaScript is extremely broad-minded about the number of arguments you can pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters are assigned the value undefined.</p>


    <p>If you write an = operator after a parameter, followed by an expression, the value of that expression will replace the argument when it is not given.</p>


    <h2>CLOSURE</h2>

    <p>The ability to treat <strong>functions as values</strong>, combined with the fact that <strong>local bindings are recreated every time a function is called</strong> 
        , brings up an interesting question: <strong>what happens to local bindings when the function call that created them is no longer active?</strong> </p>
    <script src="./functions.js"></script>
  </body>
</html>
